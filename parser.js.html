<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Licensed under the MIT License
// https://github.com/craigahobbs/markdown-model/blob/main/LICENSE

/** @module lib/parser */


/**
 * Get a Markdown model's title. Returns null if no title is found.
 *
 * @param {Object} markdown - The markdown model
 * @returns {string|null}
 */
export function getMarkdownTitle(markdown) {
    for (const part of markdown.parts) {
        if ('paragraph' in part &amp;&amp; 'style' in part.paragraph) {
            return getMarkdownParagraphText(part.paragraph);
        }
    }
    return null;
}


/**
 * Get a Markdown paragraph model's text
 *
 * @param {Object} paragraph - The markdown paragraph model
 * @returns {string}
 */
export function getMarkdownParagraphText(paragraph) {
    return paragraph.spans.map(getMarkdownSpanText).join('');
}


// Helper function to get a Markdown span model's text
function getMarkdownSpanText(span) {
    if ('image' in span) {
        return span.image.alt;
    } else if ('link' in span) {
        return span.link.spans.map(getMarkdownSpanText).join('');
    } else if ('style' in span) {
        return span.style.spans.map(getMarkdownSpanText).join('');
    }
    return span.text;
}


// Markdown regex
const rLineSplit = /\r?\n/;
const rIndent = /^(?&lt;indent>\s*)(?&lt;notIndent>.*)$/;
const rHeading = /^\s*(?&lt;heading>#{1,6})\s+(?&lt;text>.*?)\s*$/;
const rHeadingAlt = /^\s*(?&lt;heading>=+|-+)\s*$/;
const rHorizontal = /^(?:(?:\s*\*){3,}|(?:\s*-){3,}|(?:\s*_){3,})\s*$/;
const rFenced = /^(?&lt;fence>\s*(?:`{3,}|~{3,}))(?:\s*(?&lt;language>.+?))?\s*$/;
const rList = /^(?&lt;indent>\s*(?&lt;mark>-|\*|\+|[0-9]\.|[1-9][0-9]+\.)\s+)(?&lt;line>.*?)\s*$/;
const rQuote = /^(?&lt;indent>\s{0,3}>\s?)/;
const rTable = /^\s*(?::?-+:?\s*)?(?:\|\s*:?-+:?\s*)+(?:\|\s*)?$/g;
const rTableRow = /^\s*(?:(?:\\\||[^|])+\s*)?(?:\|\s*(?:\\\||[^|])*?\s*)+(?:\|\s*)?/g;
const rTableRowTrim = /^\s*\|?/;
const rTableCell = /^\s*(?&lt;cell>(?:\\\||[^|])*?)\s*\|/;
const rTableEscape = /\\(\\|)/g;


/**
 * Parse markdown text or text lines into a markdown model
 *
 * @param {string|string[]} markdown - Markdown text or text lines
 * @returns {Object} The markdown model
 */
export function parseMarkdown(markdown) {
    const markdownParts = [];
    const parts = [[0, null, 0]];
    let paragraph = null;
    let paragraphFenced = null;
    let lines = [];
    let table = null;

    // Helper function to add a markdown part
    const addPart = (part) => {
        const [, topList] = parts[parts.length - 1];
        if (topList !== null) {
            const {items} = topList.list;
            items[items.length - 1].parts.push(part);
        } else {
            markdownParts.push(part);
        }
    };

    // Helper function to close the current part
    const closeParagraph = (paragraphStyle = null) => {
        // Code block or block quote?
        if (paragraph !== null) {
            if ('quote' in paragraph) {
                // Parse the block quote markdown
                paragraph.quote.parts = parseMarkdown(lines).parts;
            } else {
                // Strip trailing blank lines
                let ixLine;
                for (ixLine = lines.length - 1; ixLine >= 0; ixLine--) {
                    if (lines[ixLine] !== '') {
                        break;
                    }
                }

                // Set the code block lines
                paragraph.codeBlock.lines = lines.slice(0, ixLine + 1);
            }
            paragraph = null;
            paragraphFenced = null;
            lines = [];
        } else if (lines.length) {
            // Paragraph
            const paragraphPart = {'paragraph': {'spans': paragraphSpans(lines.join('\n'))}};
            if (paragraphStyle !== null) {
                paragraphPart.paragraph.style = paragraphStyle;
            }
            addPart(paragraphPart);
            lines = [];
        }
        table = null;
    };

    // Helper function to get the correct [indent, list, listIndent] tuple for the given indent
    const updateParts = (indent, isList = false) => {
        // Find the part with the lesser or equal indent
        for (let ixPart = parts.length - 1; ixPart > 0; ixPart--) {
            const [curIndent,, curListIndent] = parts[ixPart];
            if (indent >= (isList ? curListIndent : curIndent)) {
                break;
            }
            parts.pop();
        }
        return parts[parts.length - 1];
    };

    // Helper function to add a paragraph line
    const addLine = (line, lineIndent, codeBlockIndent) => {
        if (lines.length) {
            // Code block line? If so, strip the indent
            if (paragraph !== null &amp;&amp; 'codeBlock' in paragraph) {
                lines.push(line.slice(codeBlockIndent));
            } else {
                lines.push(line);
            }
        } else {
            const [curIndent] = updateParts(lineIndent);
            lines.push(line.slice(curIndent));
        }
    };

    // Process markdown text line by line
    let lineNumber = 0;
    const markdownStrings = (typeof markdown === 'string' ? [markdown] : markdown);
    for (const markdownString of markdownStrings) {
        for (const lineRaw of markdownString.split(rLineSplit)) {
            const line = lineRaw.replaceAll('\t', '    ');
            const matchLine = line.match(rIndent);
            const lineIndent = matchLine.groups.indent.length;
            const emptyLine = matchLine.groups.notIndent === '';
            const matchHeading = emptyLine ? null : line.match(rHeading);
            const matchHeadingAlt = emptyLine ? null : line.match(rHeadingAlt);
            const matchFenced = emptyLine ? null : line.match(rFenced);
            const matchList = emptyLine ? null : line.match(rList);
            const [topIndent] = parts[parts.length - 1];
            const codeBlockIndent = topIndent + 4;
            lineNumber += 1;

            // Empty line?
            if (emptyLine) {
                // Code block?
                if (paragraph !== null &amp;&amp; 'codeBlock' in paragraph) {
                    addLine(line, lineIndent, topIndent);
                } else {
                    // Close any open paragraph
                    closeParagraph();
                }

            // Code block start?
            } else if (paragraphFenced === null &amp;&amp; !lines.length &amp;&amp; lineIndent >= codeBlockIndent) {
                // Add the code block part
                paragraph = {'codeBlock': {'startLineNumber': lineNumber}};
                addPart(paragraph);
                lines.push(line.slice(codeBlockIndent));

            // Block quote?
            } else if (paragraphFenced === null &amp;&amp; rQuote.test(line)) {
                // Close any open paragraph
                if (paragraph === null || !('quote' in paragraph)) {
                    closeParagraph();
                }

                // Create the block quote part
                if (paragraph === null) {
                    paragraph = {'quote': {}};
                    updateParts(lineIndent);
                    addPart(paragraph);
                }

                // Add the block quote line
                const matchQuote = line.match(rQuote);
                lines.push(line.slice(matchQuote.groups.indent.length));

            // Fenced code start?
            } else if (paragraphFenced === null &amp;&amp; matchFenced !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the code block part
                paragraph = {'codeBlock': {'startLineNumber': lineNumber}};
                if (typeof matchFenced.groups.language !== 'undefined') {
                    paragraph.codeBlock.language = matchFenced.groups.language;
                }
                paragraphFenced = matchFenced.groups.fence;
                updateParts(lineIndent);
                addPart(paragraph);

            // Fenced code end?
            } else if (paragraphFenced !== null &amp;&amp; matchFenced !== null &amp;&amp; paragraphFenced.startsWith(matchFenced.groups.fence) &amp;&amp;
                       typeof matchFenced.groups.language === 'undefined') {
                // Close the code block
                closeParagraph();

            // Fenced code line?
            } else if (paragraphFenced !== null &amp;&amp; (matchFenced === null || !paragraphFenced.startsWith(matchFenced.groups.fence))) {
                // Add the code line
                addLine(line, lineIndent, topIndent);

            // Heading?
            } else if (matchHeading !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                lines = [matchHeading.groups.text];
                closeParagraph(`h${matchHeading.groups.heading.length}`);

            // Heading (alternate syntax)?
            } else if (matchHeadingAlt !== null &amp;&amp; lineIndent &lt; codeBlockIndent &amp;&amp; parts.length === 1 &amp;&amp;
                       lines.length &amp;&amp; paragraph === null) {
                // Add the heading paragraph markdown part
                closeParagraph(matchHeadingAlt.groups.heading.startsWith('=') ? 'h1' : 'h2');

            // Horizontal rule?
            } else if (rHorizontal.test(line) &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                addPart({'hr': 1});

            // List?
            } else if (matchList !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // New list?
                const [curIndent, curList] = updateParts(lineIndent, true);
                if (curList === null || lineIndent >= curIndent) {
                    // Add the new list part
                    const list = {'list': {'items': [{'parts': []}]}};
                    const start = parseInt(matchList.groups.mark, 10);
                    if (!isNaN(start)) {
                        list.list.start = start;
                    }
                    addPart(list);
                    parts.push([matchList.groups.indent.length, list, lineIndent]);
                } else {
                    // Push the new list item
                    const listItem = {'parts': []};
                    curList.list.items.push(listItem);
                }

                // Add the text line
                lines.push(matchList.groups.line);

            // Text line
            } else {
                // Table?
                if (table !== null) {
                    // Table row?
                    const matchTableRow = line.match(rTableRow);
                    if (matchTableRow !== null) {
                        if (!('rows' in table.table)) {
                            table.table.rows = [];
                        }
                        const cells = parseTableCells(line);
                        if (cells.length > table.table.headers.length) {
                            cells.length = table.table.headers.length;
                        }
                        table.table.rows.push(cells.map((cell) => paragraphSpans(cell)));
                    } else {
                        table = null;
                    }
                } else {
                    // Table delimiter following a table header?
                    const tableHeader = (lines.length ? lines[lines.length - 1] : null);
                    const matchTable = line.match(rTable);
                    const matchTableHeader = (matchTable !== null &amp;&amp; lineIndent &lt; codeBlockIndent ? tableHeader.match(rTableRow) : null);
                    if (matchTableHeader !== null) {
                        // Does the table header match the delimiter?
                        const headers = parseTableCells(tableHeader).map((cell) => paragraphSpans(cell));
                        const aligns = parseTableCells(line).map(
                            (cell) => (cell.endsWith(':') ? (cell.startsWith(':') ? 'center' : 'right') : 'left')
                        );
                        if (headers.length === aligns.length) {
                            // Remove the table header line and close the open paragraph
                            lines.length -= 1;
                            closeParagraph();

                            // Add the table markdown part
                            table = {'table': {headers, aligns}};
                            updateParts(lineIndent);
                            addPart(table);
                        }
                    }
                }

                // Add the line to the paragraph
                if (table === null) {
                    // End code block?
                    if (paragraph !== null &amp;&amp; 'codeBlock' in paragraph &amp;&amp; lineIndent &lt; codeBlockIndent) {
                        closeParagraph();
                    }

                    // Add the paragraph line
                    addLine(line, lineIndent, codeBlockIndent);
                }
            }
        }
    }

    // Close any open paragraph
    closeParagraph();

    return {'parts': markdownParts};
}


function parseTableCells(line) {
    const cells = [];
    let matchCell;
    let lineText = line.replace(rTableRowTrim, '');
    while ((matchCell = lineText.match(rTableCell)) !== null) {
        cells.push(matchCell.groups.cell.replaceAll(rTableEscape, '$1'));
        lineText = lineText.slice(matchCell[0].length);
    }
    lineText = lineText.trim();
    if (lineText !== '') {
        cells.push(lineText);
    }
    return cells;
}


// Markdown span regex
const rEscape = /\\(\\|\*|_|\{|\}|\[|\]|\(|\)|#|\+|-|\.|!|~)/g;
const rSpans = new RegExp(
    '(?&lt;br>\\s{2}$)|' +
        '(?&lt;linkImg>\\[!\\[)(?&lt;linkImgText>[\\s\\S]*?)\\]\\((?&lt;linkImgHrefImg>[\\s\\S]*?)\\)\\]\\((?&lt;linkImgHref>[^\\s]+?)\\)|' +
        '(?&lt;link>!?\\[)(?&lt;linkText>[\\s\\S]*?)\\]\\((?&lt;linkHref>[^\\s]+?)(?:\\s*"(?&lt;linkTitle>[\\s\\S]*?)"\\s*)?\\)|' +
        '(?&lt;linkAlt>&lt;)(?&lt;linkAltHref>[[a-z]+:[^\\s]*?)>|' +
        '(?&lt;boldPre>\\\\\\*)?(?&lt;bold>\\*{2})(?!\\**\\s)(?&lt;boldText>(?:\\\\\\*|(?!\\\\\\*)[\\s\\S])*?(?:\\\\\\*|[^\\\\\\s])\\**)\\*{2}|' +
        // eslint-disable-next-line max-len
        '(?&lt;bolduPre>\\\\_|[A-Za-z0-9])?(?&lt;boldu>_{2})(?!_*\\s)(?&lt;bolduText>(?:\\\\_|(?!\\\\_)[\\s\\S])*?(?:\\\\_|[^\\\\\\s])_*)_{2}(?!_*[A-Za-z0-9])|' +
        '(?&lt;italicPre>\\\\\\*)?(?&lt;italic>\\*)(?!\\**\\s)(?&lt;italicText>(?:\\\\\\*|(?!\\\\\\*)[\\s\\S])*?(?:\\\\\\*|[^\\\\\\s]))\\*|' +
        // eslint-disable-next-line max-len
        '(?&lt;italicuPre>\\\\_|[A-Za-z0-9])?(?&lt;italicu>_)(?!_*\\s)(?&lt;italicuText>(?:\\\\_|(?!\\\\_)[\\s\\S])*?(?:\\\\_|[^\\\\\\s]))_(?!_*[A-Za-z0-9])|' +
        '(?&lt;strike>~{1,2})(?!~)(?&lt;strikeText>(?:\\\\~|(?!\\\\~)[\\s\\S])*?(?:\\\\~|[^\\\\~]))\\k&lt;strike>(?!~)|' +
        '(?&lt;code>`+)(?!`)(?&lt;codeSp> )?(?&lt;codeText>(?:\\k&lt;code>`+|(?!\\k&lt;codeSp>\\k&lt;code>(?!`))[\\s\\S])*)\\k&lt;codeSp>\\k&lt;code>(?!`)',
    'mg'
);
const rSpanNewlinesEnd = /[\r\n]$/;
const rSpanNewlines = /[\r\n]/g;


// Helper function to translate markdown paragraph text to a markdown paragraph span model array
function paragraphSpans(text) {
    const spans = [];

    // Iterate the span matches
    let ixSearch = 0;
    for (const match of text.matchAll(rSpans)) {
        // Add any preceding text
        if (ixSearch &lt; match.index) {
            spans.push({'text': removeEscapes(text.slice(ixSearch, match.index))});
        }

        // Line break?
        if (typeof match.groups.br !== 'undefined') {
            spans.push({'br': 1});

        // Link-image span?
        } else if (typeof match.groups.linkImg !== 'undefined') {
            const imgSpan = {'image': {'src': removeEscapes(match.groups.linkImgHrefImg), 'alt': removeEscapes(match.groups.linkImgText)}};
            const span = {'link': {'href': removeEscapes(match.groups.linkImgHref), 'spans': [imgSpan]}};
            spans.push(span);

        // Link span?
        } else if (match.groups.link === '[') {
            const span = {'link': {'href': removeEscapes(match.groups.linkHref), 'spans': paragraphSpans(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.link.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Link span (alternate syntax)?
        } else if (typeof match.groups.linkAlt !== 'undefined') {
            spans.push({'link': {'href': removeEscapes(match.groups.linkAltHref), 'spans': paragraphSpans(match.groups.linkAltHref)}});

        // Image span?
        } else if (match.groups.link === '![') {
            const span = {'image': {'src': removeEscapes(match.groups.linkHref), 'alt': removeEscapes(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.image.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Bold style-span
        } else if (typeof match.groups.bold !== 'undefined' || typeof match.groups.boldu !== 'undefined') {
            const boldPre = match.groups.boldPre ?? match.groups.bolduPre ?? null;
            const bold = match.groups.bold ?? match.groups.boldu;
            const boldText = match.groups.boldText ?? match.groups.bolduText;
            if (bold === '__' &amp;&amp; boldPre !== null &amp;&amp; boldPre !== '\\_') {
                spans.push({'text': `${boldPre}${bold}${boldText}${bold}`});
            } else {
                if (boldPre !== null) {
                    spans.push({'text': removeEscapes(boldPre)});
                }
                spans.push({'style': {'style': 'bold', 'spans': paragraphSpans(boldText)}});
            }

        // Italic style-span
        } else if (typeof match.groups.italic !== 'undefined' || typeof match.groups.italicu !== 'undefined') {
            const italicPre = match.groups.italicPre ?? match.groups.italicuPre ?? null;
            const italic = match.groups.italic ?? match.groups.italicu;
            const italicText = match.groups.italicText ?? match.groups.italicuText;
            if (italic === '_' &amp;&amp; italicPre !== null &amp;&amp; italicPre !== '\\_') {
                spans.push({'text': `${italicPre}${italic}${italicText}${italic}`});
            } else {
                if (italicPre !== null) {
                    spans.push({'text': removeEscapes(italicPre)});
                }
                spans.push({'style': {'style': 'italic', 'spans': paragraphSpans(italicText)}});
            }

        // Strikethrough style-span
        } else if (typeof match.groups.strike !== 'undefined') {
            spans.push({'style': {'style': 'strikethrough', 'spans': paragraphSpans(match.groups.strikeText)}});

        // Code span
        } else if (typeof match.groups.code !== 'undefined') {
            const codeText = match.groups.codeText.replace(rSpanNewlinesEnd, '').replaceAll(rSpanNewlines, ' ');
            spans.push({'code': codeText});
        }

        ixSearch = match.index + match[0].length;
    }

    // Add any remaining text
    if (ixSearch &lt; text.length) {
        spans.push({'text': removeEscapes(text.slice(ixSearch))});
    }

    return spans;
}


function removeEscapes(text) {
    return text.replace(rEscape, '$1');
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-lib_elements.html">lib/elements</a></li><li><a href="module-lib_model.html">lib/model</a></li><li><a href="module-lib_parser.html">lib/parser</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
