<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Licensed under the MIT License
// https://github.com/craigahobbs/markdown-model/blob/main/LICENSE


/**
 * Encode a string for inclusion in Markdown text
 *
 * @param {string} text
 * @returns {string}
 */
export function encodeMarkdownText(text) {
    return text.replace(rEncodeMarkdownText, '\\$1');
}

const rEncodeMarkdownText = /([\\[\]()*])/g;


// Markdown regex
const rLineSplit = /\r?\n/;
const rIndent = /^(?&lt;indent>\s*)(?&lt;notIndent>.*)$/;
const rHeading = /^\s*(?&lt;heading>#{1,6})\s+(?&lt;text>.*?)\s*$/;
const rHeadingAlt = /^\s*(?&lt;heading>=+|-+)\s*$/;
const rHorizontal = /^(?:(?:\s*\*){3,}|(?:\s*-){3,}|(?:\s*_){3,})\s*$/;
const rFenced = /^(?&lt;fence>\s*(?:`{3,}|~{3,}))(?:\s*(?&lt;language>.+?))?\s*$/;
const rList = /^(?&lt;indent>\s*(?&lt;mark>-|\*|\+|[0-9]\.|[1-9][0-9]+\.)\s+)(?&lt;line>.*?)\s*$/;


/**
 * Parse markdown text or text lines into a markdown model
 *
 * @param {string|string[]} markdown - Markdown text or text lines
 * @returns {Object} The markdown model
 */
export function parseMarkdown(markdown) {
    const markdownParts = [];
    const parts = [[0, null, 0]];
    let paragraph = null;
    let paragraphFenced = null;
    let lines = [];

    // Helper function to add a markdown part
    const addPart = (part) => {
        const [, topList] = parts[parts.length - 1];
        if (topList !== null) {
            const {items} = topList.list;
            items[items.length - 1].parts.push(part);
        } else {
            markdownParts.push(part);
        }
    };

    // Helper function to close the current part
    const closeParagraph = (paragraphStyle = null) => {
        // Code block?
        if (paragraph !== null) {
            // Strip trailing blank lines
            let ixLine;
            for (ixLine = lines.length - 1; ixLine >= 0; ixLine--) {
                if (lines[ixLine] !== '') {
                    break;
                }
            }
            paragraph.codeBlock.lines = lines.splice(0, ixLine + 1);
            paragraph = null;
            paragraphFenced = null;
        } else if (lines.length) {
            // Paragraph
            const paragraphPart = {'paragraph': {'spans': paragraphSpans(lines.join('\n'))}};
            if (paragraphStyle !== null) {
                paragraphPart.paragraph.style = paragraphStyle;
            }
            addPart(paragraphPart);
        }
        lines = [];
    };

    // Helper function to get the correct [indent, list, listIndent] tuple for the given indent
    const updateParts = (indent, isList = false) => {
        // Find the part with the lesser or equal indent
        for (let ixPart = parts.length - 1; ixPart > 0; ixPart--) {
            const [curIndent,, curListIndent] = parts[ixPart];
            if (indent >= (isList ? curListIndent : curIndent)) {
                break;
            }
            parts.pop();
        }
        return parts[parts.length - 1];
    };

    // Helper function to add a paragraph line
    const addLine = (line, lineIndent, codeBlockIndent) => {
        if (lines.length) {
            // Code block line? If so, trip the indent
            if (paragraph !== null) {
                lines.push(line.slice(codeBlockIndent));
            } else {
                lines.push(line);
            }
        } else {
            const [curIndent] = updateParts(lineIndent);
            lines.push(line.slice(curIndent));
        }
    };

    // Process markdown text line by line
    for (const markdownString of (typeof markdown === 'string' ? [markdown] : markdown)) {
        for (const lineRaw of markdownString.split(rLineSplit)) {
            const line = lineRaw.replace('\t', '    ');
            const matchLine = line.match(rIndent);
            const lineIndent = matchLine.groups.indent.length;
            const emptyLine = matchLine.groups.notIndent === '';
            const matchHeading = emptyLine ? null : line.match(rHeading);
            const matchHeadingAlt = emptyLine ? null : line.match(rHeadingAlt);
            const matchFenced = emptyLine ? null : line.match(rFenced);
            const matchList = emptyLine ? null : line.match(rList);
            const [topIndent] = parts[parts.length - 1];
            const codeBlockIndent = topIndent + 4;

            // Empty line?
            if (emptyLine) {
                // Close any open paragraph
                if (paragraph !== null) {
                    addLine(line, lineIndent, topIndent);
                } else {
                    closeParagraph();
                }

            // Code block start?
            } else if (paragraphFenced === null &amp;&amp; !lines.length &amp;&amp; lineIndent >= codeBlockIndent) {
                // Add the code block part
                paragraph = {'codeBlock': {}};
                addPart(paragraph);
                lines.push(line.slice(codeBlockIndent));

            // Fenced code start?
            } else if (paragraphFenced === null &amp;&amp; matchFenced !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the code block part
                paragraph = {'codeBlock': {}};
                if (typeof matchFenced.groups.language !== 'undefined') {
                    paragraph.codeBlock.language = matchFenced.groups.language;
                }
                paragraphFenced = matchFenced.groups.fence;
                addPart(paragraph);

            // Fenced code end?
            } else if (paragraphFenced !== null &amp;&amp; matchFenced !== null &amp;&amp; paragraphFenced.startsWith(matchFenced.groups.fence) &amp;&amp;
                       typeof matchFenced.groups.language === 'undefined') {
                // Close the code block
                closeParagraph();

            // Fenced code line?
            } else if (paragraphFenced !== null &amp;&amp; matchFenced === null) {
                // Add the code line
                addLine(line, lineIndent, topIndent);

            // Heading?
            } else if (matchHeading !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                lines = [matchHeading.groups.text];
                closeParagraph(`h${matchHeading.groups.heading.length}`);

            // Heading (alternate syntax)?
            } else if (matchHeadingAlt !== null &amp;&amp; lineIndent &lt; codeBlockIndent &amp;&amp; parts.length === 1 &amp;&amp;
                       lines.length &amp;&amp; paragraph === null) {
                // Add the heading paragraph markdown part
                closeParagraph(matchHeadingAlt.groups.heading.startsWith('=') ? 'h1' : 'h2');

            // Horizontal rule?
            } else if (rHorizontal.test(line) &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                addPart({'hr': null});

            // List?
            } else if (matchList !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // New list?
                const [curIndent, curList] = updateParts(lineIndent, true);
                if (curList === null || lineIndent >= curIndent) {
                    // Add the new list part
                    const list = {'list': {'items': [{'parts': []}]}};
                    const start = parseInt(matchList.groups.mark, 10);
                    if (!isNaN(start)) {
                        list.list.start = start;
                    }
                    addPart(list);
                    parts.push([matchList.groups.indent.length, list, lineIndent]);
                } else {
                    // Push the new list item
                    const listItem = {'parts': []};
                    curList.list.items.push(listItem);
                }

                // Add the text line
                lines.push(matchList.groups.line);

            // Text line
            } else {
                // End code block first?
                if (paragraph !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                    closeParagraph();
                }

                // Add the paragraph line
                addLine(line, lineIndent, codeBlockIndent);
            }
        }
    }

    // Close any open paragraph
    closeParagraph();

    return {'parts': markdownParts};
}


// Markdown span regex
const rEscape = /\\(\\|\*|_|\{|\}|\[|\]|\(|\)|#|\+|-|\.|!)/g;
const rSpans = new RegExp(
    '(?&lt;br>\\s{2}$)|' +
        '(?&lt;linkImg>\\[!\\[)(?&lt;linkImgText>[\\s\\S]*?)\\]\\((?&lt;linkImgHrefImg>[\\s\\S]*?)\\)\\]\\((?&lt;linkImgHref>[^\\s]+?)\\)|' +
        '(?&lt;link>!?\\[)(?&lt;linkText>[\\s\\S]*?)\\]\\((?&lt;linkHref>[^\\s]+?)(?:\\s*"(?&lt;linkTitle>[\\s\\S]*?)"\\s*)?\\)|' +
        '(?&lt;linkAlt>&lt;)(?&lt;linkAltHref>[[a-z]+:[^\\s]*?)>|' +
        '(?&lt;boldItalic>\\*{3})(?!\\s)(?&lt;boldItalicText>[\\s\\S]*?[^\\s]\\**)\\*{3}|' +
        '(?&lt;bold>\\*{2})(?!\\s)(?&lt;boldText>[\\s\\S]*?[^\\s]\\**)\\*{2}|' +
        '(?&lt;italic>\\*)(?!\\s)(?&lt;italicText>[\\s\\S]*?[^\\s]\\**)\\*',
    'mg'
);


// Helper function to translate markdown paragraph text to a markdown paragraph span model array
function paragraphSpans(text) {
    const spans = [];

    // Iterate the span matches
    let ixSearch = 0;
    for (const match of text.matchAll(rSpans)) {
        // Add any preceding text
        if (ixSearch &lt; match.index) {
            spans.push({'text': removeEscapes(text.slice(ixSearch, match.index))});
        }

        // Line break?
        if (typeof match.groups.br !== 'undefined') {
            spans.push({'br': null});

        // Link-image span?
        } else if (typeof match.groups.linkImg !== 'undefined') {
            const imgSpan = {'image': {'src': removeEscapes(match.groups.linkImgHrefImg), 'alt': removeEscapes(match.groups.linkImgText)}};
            const span = {'link': {'href': removeEscapes(match.groups.linkImgHref), 'spans': [imgSpan]}};
            spans.push(span);

        // Link span?
        } else if (match.groups.link === '[') {
            const span = {'link': {'href': removeEscapes(match.groups.linkHref), 'spans': paragraphSpans(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.link.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Link span (alternate syntax)?
        } else if (match.groups.linkAlt === '&lt;') {
            spans.push({'link': {'href': removeEscapes(match.groups.linkAltHref), 'spans': paragraphSpans(match.groups.linkAltHref)}});

        // Image span?
        } else if (match.groups.link === '![') {
            const span = {'image': {'src': removeEscapes(match.groups.linkHref), 'alt': removeEscapes(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.image.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Bold-italic style-span
        } else if (match.groups.boldItalic === '***') {
            spans.push({'style': {'style': 'bold', 'spans': [
                {'style': {'style': 'italic', 'spans': paragraphSpans(match.groups.boldItalicText)}}
            ]}});

        // Bold style-span
        } else if (match.groups.bold === '**') {
            spans.push({'style': {'style': 'bold', 'spans': paragraphSpans(match.groups.boldText)}});

        // Italic style-span
        } else if (match.groups.italic === '*') {
            spans.push({'style': {'style': 'italic', 'spans': paragraphSpans(match.groups.italicText)}});
        }

        ixSearch = match.index + match[0].length;
    }

    // Add any remaining text
    if (ixSearch &lt; text.length) {
        spans.push({'text': removeEscapes(text.slice(ixSearch))});
    }

    return spans;
}


// Helper function to remove escapes from a string
function removeEscapes(text) {
    return text.replace(rEscape, '$1');
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#encodeMarkdownText">encodeMarkdownText</a></li><li><a href="global.html#getBaseURL">getBaseURL</a></li><li><a href="global.html#getMarkdownParagraphText">getMarkdownParagraphText</a></li><li><a href="global.html#getMarkdownTitle">getMarkdownTitle</a></li><li><a href="global.html#isRelativeURL">isRelativeURL</a></li><li><a href="global.html#markdownElements">markdownElements</a></li><li><a href="global.html#parseMarkdown">parseMarkdown</a></li><li><a href="global.html#validateMarkdownModel">validateMarkdownModel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
